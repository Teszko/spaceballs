<html>
    <head>
        <title>Spaceballs</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100% }
        </style>
    </head>
    <body>
        <script src="cannon.min.js"></script>
        <script src="three.min.js"></script>
        <script src="orbitControls.js"></script>
        <script src="utils.js"></script>
        <script>
            sphere_list = [];
            connection_list = [];

            var clock = new THREE.Clock();
            scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 9;

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            var controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableZoom = true;

            var basic_material = new THREE.MeshLambertMaterial({color: 0xffff00});

            var directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(1, 1, 0);
            scene.add(directionalLight);

            var light = new THREE.AmbientLight(0x404040); // soft white light
            scene.add(light);

            /*
            var sphereCenter = new THREE.Object3D();
            scene.add(sphereCenter);

            var particles, lineGeometry;
            var line;
            function addParticleSphere (parent, numParticles, world) {
                var offsetX = 0;
                var offsetY = 0;
                var offsetZ = 0;
                var radius = 0.5;
                var offsetCenter = 3;
                var lineMaterial = new THREE.LineBasicMaterial({
                    color: 0xffffff
                });
                var lastBody = null;
                lineGeometry = new THREE.Geometry();
                particles = new THREE.Geometry();
                var particleCount = numParticles,
                        pMaterial = new THREE.PointsMaterial({
                            color: 0x7777ff,
                            size: 0.02
                        });

                var beta = 0;
                for (var i=0; i<particleCount; i++) {
                    var alpha = 360 / particleCount * i;
                    var offset = (Math.random() * radius + offsetCenter);
                    var a = Math.sin(alpha) * offset;
                    var b = Math.cos(alpha) * offset;
                    beta += 5 * Math.random();
                    beta %= 360;
                    var pX = Math.sin(beta) * a + offsetX;
                    var pY = Math.sin(beta) * b + offsetY;
                    var pZ = Math.cos(beta) * offset + offsetZ;

                    var sphereBody = new CANNON.Body({
                        mass: 0.1, // kg
                        position: new CANNON.Vec3(pX, pY, pZ), // m
                        shape: new CANNON.Sphere(0.01) // radius in m
                    });
                    world.addBody(sphereBody);


                    if (lastBody) {
                        world.addConstraint(new CANNON.DistanceConstraint(sphereBody, lastBody, 3, 0.001));
                    }
                    // DistanceConstraint ( bodyA  bodyB  [distance]  [maxForce=1e6] )

                    console.log(elem);

                    lineGeometry.vertices.push(sphereBody.position);
                    particle = new THREE.Vector3(sphereBody.position);
                    particles.vertices.push(particle);
                    lastBody = sphereBody;
                }

                line = new THREE.Line(lineGeometry, lineMaterial);
                var particleSystem = new THREE.Points(particles, pMaterial);
                console.log(particleSystem);
                parent.add(particleSystem);
                parent.add(line);
            }
            */
            /*
             * PHYSICS
             */

            var world = new CANNON.World();
            world.gravity.set(0, 0, 0); // m/sÂ²
            var maxSubSteps = 3;
            var fixedTimeStep = 1.0 / 60.0; // seconds

            /*
            var a = new Sphere(basic_material, 0, 1, 0);
            var b = new Sphere(basic_material, 1, 0, 0);
            var c = new Sphere(basic_material, 0, 0, 1);
            var c_a = new Connection(a, b); */

            var particleCount = 300;
            var radius = 30;
            var offset = 1;
            var last_sphere = null;
            var beta = 0;
            for (var i=0; i<particleCount; i++) {
                var alpha = 360 / particleCount * i;
                var offset = (Math.random() * radius);
                var a = Math.sin(alpha) * offset;
                var b = Math.cos(alpha) * offset;
                beta += 5 * Math.random();
                beta %= 360;
                var pX = Math.sin(beta) * a;
                var pY = Math.sin(beta) * b;
                var pZ = Math.cos(beta) * offset;

                var current_sphere = new Sphere(basic_material, pX, pY, pZ);
                if (last_sphere) {
                    var c_a = new Connection(current_sphere, last_sphere, 0.7);
                }

                last_sphere = current_sphere;
            }

            var num_random_connections = 10;
            for (var z=0; z<num_random_connections; z++) {
                var rand1 = Math.round(Math.random() * (sphere_list.length-1));
                var rand2 = Math.round(Math.random() * (sphere_list.length-1));
                if (Math.abs(rand2-rand1) == 1) {
                    z--;
                    continue;
                }
                console.log(sphere_list[rand1]);
                var c_b = new Connection(sphere_list[rand1], sphere_list[rand2], 1.5);
            }

            clock.getDelta();
            function updatePhysics(world) {
                world.step(fixedTimeStep, clock.getDelta(), maxSubSteps);

                for (var j=0; j<sphere_list.length; j++)
                    sphere_list[j].update();

                for (var h=0; h<connection_list.length; h++)
                    connection_list[h].update();
            }

            function render() {
                requestAnimationFrame( render );

                updatePhysics(world);

                renderer.render(scene, camera);
            }
            render();
        </script>
    </body>
</html>